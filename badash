#!/usr/bin/env bash

# TODO: what things should I set here, like pipefail and lastpipe and so forth?


########## FUNCTIONS ##########

# generate code to exit with a message if there is an error
gen_exit_on_error() {
  # arguments:
  local varname="$1" # write the generated code to this variable
  local padding="$2" # generate the code to match the padding of the surrounding code
  local exit_info="$3" # 1 or 2 strings: the exit message, and optional code to run before exiting

  if [ -z "$exit_info" ]
  then
    echo "" >&2
    echo "badash: Wrong number of arguments to @exit_on_error: expected 1 or 2, got 0" >&2
    exit 1
  fi

  # split up the strings, one per line, preserving spaces inside the quotes
  # (see https://superuser.com/a/1066541)
  local exit_options="$(eval "for arg in $exit_info; do echo \$arg; done")"
  readarray -t exit_options <<< "$exit_options"
  local num_exit_strings="${#exit_options[@]}"

  # generate any code to run before exiting
  local run_code=""
  if [ "$num_exit_strings" -eq 1 ]
  then
    run_code="# (no code to run before exit)"
  elif [ "$num_exit_strings" -eq 2 ]
  then
    # run this code before exiting
    run_code="${exit_options[1]}"
  else
    echo "" >&2
    echo "badash: Wrong number of arguments to @exit_on_error: expected 1 or 2, got $num_exit_strings" >&2
    exit 1
  fi

  # generate the code block for this
  # TODO: colored output for the error message
  local temp_code=""
  read -d '' temp_code <<END_GEN_CODE
${padding}exit_code="\$?"
${padding}if [ "\$exit_code" -ne 0 ]
${padding}then
${padding}  echo "${exit_options[0]}" >&2
${padding}  $run_code
${padding}  exit "\$exit_code"
${padding}fi
END_GEN_CODE

  printf -v "$varname" "$temp_code"
}

# generate code to wait for a keypress
gen_wait_for_keypress() {
  # arguments:
  local varname="$1" # write the generated code to this variable
  local padding="$2" # generate the code to match the padding of the surrounding code
  local prompt_str="$3" # string to prompt the user (should be enclosed in quotes)

  # TODO: check the prompt string somehow? make sure it's a string?

  local temp_code=""
  # I could use read -p to display the prompt, but that doesn't show up for automatic input
  # (and I want to check the output in the test)
  read -d '' temp_code <<END_GEN_CODE
${padding}echo -n $prompt_str
${padding}read -n1 -s
END_GEN_CODE

  printf -v "$varname" "$temp_code"
}


########## EXECUTION START ##########

# get the path to the script
if [ -z "$1" ]
then
  echo "badash: Missing argument: script to execute" >&2
  exit 1
fi
script_file="$1"
shift

# TODO: help argument to describe usage

# ensure the cache dir exists
script_cache="$HOME/.badash"
mkdir -p "$script_cache"

# setup variables
current_line_num="0"

# structure of the generated code
generated_header=()  # header, including the shebang
# generated_imports=() # imported functions and variables
generated_body=()    # the main body of executable code

# generated code will be written to this file
generated_script="$script_cache/$(basename "$script_file")"

# first line in the file, so that bash will execute the script
generated_header+=( "#!/usr/bin/env bash" )

# read the script line by line
while IFS= read -r line
do
  (( current_line_num++ ))

  if [ "$current_line_num" == "1" ] && [ "${line:0:2}" == "#!" ]
  then
    # remove the shebang line
    continue

  # generate code for system_is_darwin?, system_is_linux?, etc.
  # (which is case-insensitive, so system_is_Darwin? == system_is_DARWIN? == system_is_darwin?)
  # TODO: this should start with '@' - figure out how to do deprecation
  elif [[ "$line" =~ system_is_(.*)\? ]]
  then
    system="${BASH_REMATCH[1]}"
    system_lowercase="$(echo "$system" | tr '[:upper:]' '[:lower:]')"
    # for example:
    # system_is_Darwin?  -->  [ "$(uname -s | tr [:upper:] [:lower:])" == "darwin" ]
    replaced_test="${line/system_is_$system?/[ \"\$(uname -s | tr '[:upper:]' '[:lower:]')\" == \"$system_lowercase\" ]}"
    generated_body+=( "$replaced_test" )

  # exit with an error message if the previous command failed
  elif [[ "$line" =~ ^(\ *)@exit_on_error\ *(.*)$ ]]
  then
    padding="${BASH_REMATCH[1]}"
    exit_info_strings="${BASH_REMATCH[2]}"
    gen_exit_on_error gen_exit "$padding" "$exit_info_strings"
    generated_body+=( "$gen_exit" )

  elif [[ "$line" =~ ^(\ *)@wait_for_keypress\ (.*)$ ]]
  then
    padding="${BASH_REMATCH[1]}"
    prompt_str="${BASH_REMATCH[2]}"
    gen_wait_for_keypress gen_keypress "$padding" "$prompt_str"
    generated_body+=( "$gen_keypress" )

  # TODO: @confirm_y/n
  # but, how to do default for that (specify default yes or no)
  # like @confirm_Y/n vs. @confirm_y/N ?? guess that would work...

  else
    # no imports or anything to do, just add to the body
    generated_body+=( "$line" )

  fi
done <"$script_file"

# write all the lines to the script
echo "$(
  IFS=$'\n';
  echo "${generated_header[*]}";
  # echo "${generated_imports[*]}";
  echo "${generated_body[*]}";
)" > "$generated_script"

# make sure it is executable
chmod +x "$generated_script"

# execute the generated script
"$generated_script" "$@"

# TODO: catch/identify errors and print the line that they came from
# (in the original file or library or here)
